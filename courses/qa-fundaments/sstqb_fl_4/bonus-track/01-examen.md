<p align=center>
<a href="https://testeandoya.com">
  <img src="testeandoya_logo.jpg" alt="TesteandoYa" style="max-width: 20%; height: auto; display: block; margin: auto;" />
</a>
</p>

# Examen 1: Autoevaluación tras la semana 4

**Duración recomendada**: 30 minutos  
**Preguntas**: 20  
**Criterio de aprobación**: 65% (13 respuestas correctas)

---

## Preguntas

1. ¿Cuál de los siguientes es un *principio fundamental del testing*?

    a) El testing demuestra la ausencia total de defectos  
    b) El testing debe hacerse solo al final del desarrollo  
    c) El testing depende del código fuente  
    d) El testing detecta defectos, pero no garantiza su ausencia  

2. En el modelo *V*, ¿cuál de las siguientes afirmaciones es correcta?

    a) El diseño de pruebas comienza tras la codificación  
    b) Cada fase de desarrollo tiene una fase de prueba asociada  
    c) Solo se prueban los entregables finales  
    d) No se planifican pruebas en las primeras etapas  

3. ¿Qué se entiende por *prueba de integración*?

    a) Validación de requisitos por parte del cliente  
    b) Verificación de componentes individuales  
    c) Evaluación del sistema completo  
    d) Prueba de interacción entre unidades/componentes  

4. ¿Cuál de los siguientes roles NO forma parte típica en una revisión técnica?

    a) Revisor  
    b) Moderador  
    c) Programador externo  
    d) Autor  

5. ¿Qué técnica de prueba se basa en particionar los datos en clases válidas e inválidas?

    a) Prueba de decisión  
    b) Prueba de condición múltiple  
    c) Partición de equivalencia  
    d) Análisis de causa-efecto  

6. En una prueba de caja blanca, se evalúa principalmente:

    a) La experiencia del usuario  
    b) La lógica interna del código  
    c) La documentación del producto  
    d) La interfaz gráfica  

7. ¿Cuál de las siguientes pruebas sería estática?

    a) Prueba de rendimiento  
    b) Revisión de código  
    c) Prueba de regresión  
    d) Prueba de integración  

8. ¿Qué diferencia clave existe entre una inspección y una revisión informal?

    a) Las inspecciones no generan actas  
    b) Las revisiones informales son obligatorias  
    c) Las inspecciones son más estructuradas y con roles definidos  
    d) Las revisiones informales requieren herramientas automatizadas  

9. ¿Cuál es el objetivo principal de una técnica basada en experiencia?

    a) Automatizar pruebas  
    b) Reproducir errores ya conocidos  
    c) Aplicar la intuición del tester  
    d) Validar criterios de aceptación  

10. En el testing basado en especificaciones, ¿qué técnica usamos para validar condiciones límite?

    a) Análisis de valor límite  
    b) Cobertura de condición  
    c) Trazabilidad inversa  
    d) Análisis de decisiones  

11. ¿Cuál de los siguientes sería un artefacto sujeto a revisión?

    a) Sprint backlog  
    b) Código compilado  
    c) Documento de diseño técnico  
    d) Branch de Git  

12. ¿Qué significa “exhaustividad inalcanzable” en pruebas?

    a) Que no pueden ejecutarse todas las funciones  
    b) Que no se puede testear sin usuarios  
    c) Que no se pueden probar todos los inputs posibles  
    d) Que no se revisan todos los informes  

13. ¿Cuál de estas técnicas requiere conocer la estructura interna del software?

    a) Partición de equivalencia  
    b) Prueba de caminos  
    c) Prueba de transición de estados  
    d) Prueba basada en escenarios  

14. En un proceso de revisión, el *autor* del documento es responsable de:

    a) Identificar errores automáticamente  
    b) Aceptar o rechazar sugerencias  
    c) Moderar la reunión  
    d) Controlar métricas de calidad  

15. ¿Cuál es un objetivo de las pruebas estáticas?

    a) Ejecutar el software en diferentes entornos  
    b) Reducir defectos desde etapas tempranas  
    c) Probar funcionalidades críticas  
    d) Validar la UX del usuario  

16. En análisis de decisión, ¿qué estructura se usa normalmente?

    a) Gráfico de flujo  
    b) Matriz de decisión  
    c) Mapa de riesgo  
    d) Gráfico de caja  

17. ¿Cuál sería un beneficio típico de una revisión bien realizada?

    a) Aumentar los bugs en producción  
    b) Reducir la comunicación entre equipos  
    c) Detectar defectos antes de la prueba dinámica  
    d) Evitar escribir documentación  

18. ¿Cuál de estas opciones es un tipo de prueba dinámica?

    a) Validación de requisitos  
    b) Revisión por pares  
    c) Test de regresión  
    d) Evaluación de propuestas técnicas  

19. ¿Qué objetivo cumple la técnica *state transition*?

    a) Evaluar entradas numéricas  
    b) Probar distintos estados del sistema y sus transiciones  
    c) Validar la cobertura de código  
    d) Medir rendimiento del backend  

20. ¿Qué es una técnica de caja negra?

    a) Analizar el flujo de control del código  
    b) Probar sin conocer la estructura interna  
    c) Verificar commits recientes  
    d) Identificar errores en dependencias  

---

## Respuestas correctas

1. **d)** El testing detecta defectos, pero no garantiza su ausencia  
   **Explicación**: El testing puede identificar errores, pero no garantiza que el software esté libre de defectos.

2. **b)** Cada fase de desarrollo tiene una fase de prueba asociada  
   **Explicación**: El modelo *V* vincula cada fase de desarrollo con su correspondiente fase de prueba, desde el análisis de requisitos hasta la integración.

3. **d)** Prueba de interacción entre unidades/componentes  
   **Explicación**: Las pruebas de integración verifican la interacción entre diferentes componentes del sistema.

4. **c)** Programador externo  
   **Explicación**: En una revisión técnica, el revisor no debe ser un programador externo, ya que debe tener conocimiento del código bajo revisión.

5. **c)** Partición de equivalencia  
   **Explicación**: La técnica de partición de equivalencia divide los datos de entrada en clases válidas e inválidas para reducir la cantidad de casos a probar.

6. **b)** La lógica interna del código  
   **Explicación**: La caja blanca se centra en el análisis y prueba de la estructura interna del código.

7. **b)** Revisión de código  
   **Explicación**: Las revisiones de código son un ejemplo de pruebas estáticas, ya que no requieren ejecutar el software, sino revisar el código fuente.

8. **c)** Las inspecciones son más estructuradas y con roles definidos  
   **Explicación**: Las inspecciones son una forma formal de revisión con roles establecidos, mientras que las revisiones informales suelen ser menos estructuradas.

9. **c)** Aplicar la intuición del tester  
   **Explicación**: Las técnicas basadas en experiencia aprovechan el conocimiento y la intuición del tester, a menudo para identificar posibles defectos que no están cubiertos por pruebas formales.

10. **a)** Análisis de valor límite  
    **Explicación**: El análisis de valor límite se centra en las entradas cercanas a los límites de los rangos, que son donde se pueden producir más errores.

11. **c)** Documento de diseño técnico  
    **Explicación**: Los artefactos técnicos como los documentos de diseño son susceptibles de revisión para asegurar la calidad desde las etapas tempranas del desarrollo.

12. **c)** Que no se pueden probar todos los inputs posibles  
    **Explicación**: La exhaustividad inalcanzable se refiere a la imposibilidad de probar todos los casos posibles debido a limitaciones prácticas o de tiempo.

13. **b)** Prueba de caminos  
    **Explicación**: Las pruebas de caminos están basadas en el análisis de la lógica de control, cubriendo diferentes rutas que el código puede tomar.

14. **b)** Aceptar o rechazar sugerencias  
    **Explicación**: El autor tiene la responsabilidad de revisar las sugerencias del equipo de revisión y decidir si las acepta o las rechaza.

15. **b)** Reducir defectos desde etapas tempranas  
    **Explicación**: Las pruebas estáticas, como las revisiones de código, ayudan a identificar defectos antes de que el código sea ejecutado, lo que mejora la calidad desde el inicio.

16. **b)** Matriz de decisión  
    **Explicación**: En el análisis de decisiones, se utiliza una matriz de decisión para documentar y analizar las diferentes condiciones que pueden influir en el flujo del sistema.

17. **c)** Detectar defectos antes de la prueba dinámica  
    **Explicación**: Una revisión bien realizada ayuda a encontrar errores antes de la fase de pruebas dinámicas, lo que reduce el costo de corrección.

18. **c)** Test de regresión  
    **Explicación**: Las pruebas dinámicas, como las de regresión, implican la ejecución de software para verificar que los cambios no hayan introducido nuevos errores.

19. **b)** Probar distintos estados del sistema y sus transiciones  
    **Explicación**: La técnica de *state transition* se centra en probar cómo el sistema cambia entre diferentes estados en respuesta a entradas específicas.

20. **b)** Probar sin conocer la estructura interna  
    **Explicación**: Las pruebas de caja negra se centran en probar el sistema sin considerar su estructura interna, validando sus funcionalidades externas.

---

- [Volver al índice](../readme.md)

---

## Licencia

Este curso está registrado en Safe Creative y licenciado bajo:

[**🛡️ Safe Creative: Registro de Derechos**](https://www.safecreative.org)  
[**🪪 Creative Commons BY-NC-ND 4.0 Internacional**](http://creativecommons.org/licenses/by-nc-nd/4.0/)

[![Licencia CC BY-NC-ND 4.0](https://licensebuttons.net/l/by-nc-nd/4.0/88x31.png)](http://creativecommons.org/licenses/by-nc-nd/4.0/)

> Puedes **compartir** el contenido con atribución, pero **no modificarlo ni utilizarlo con fines comerciales**.  
> Cualquier uso comercial requiere **acuerdo previo por escrito** con el autor.

---

© 2025 Diego González Fernández  
[LinkedIn](https://www.linkedin.com/in/diego-gonzalez-fernandez)
